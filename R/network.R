#' Perform network inference with SparCC on a tidytacos object, 
#' after rarefaction of the taxa. See \link[SpiecEasi]{sparcc}.
#'
#' @param ta a tidytacos object
#' @param rarefact Rarefaction degree: percentage of samples the taxon needs to be present in.
#' @param iter Number of iterations in the outer loop
#' @param inner_iter Number of iterations in the inner loop
#' @param th absolute value of correlations below this threshold are 
#' considered zero by the inner SparCC loop.
#' 
#'@export
sparcc <- function(ta, rarefact = 0.05, iter=20, inner_iter=10, th=0.1, taxon_name = taxon, sample_name = sample) {
  force_optional_dependency(
    "SpiecEasi",
    "\nInstall using: install_github('zdk123/SpiecEasi')"
  )


  sample_name <- rlang::enquo(sample_name)
  taxon_name <- rlang::enquo(taxon_name)

  cutoff <- nrow(ta$samples) * rarefact
  if (!"occurrence" %in% names(ta$taxa)) {
    ta_occ <- ta %>% add_occurrences()
  } else {
    ta_occ <- ta
  }
  ta_occ <- ta_occ %>%
    filter_taxa(occurrence >= cutoff)
  counts <- ta_occ %>%
    counts_matrix(sample_name = !!sample_name, taxon_name = !!taxon_name)
  sparcc.out <- SpiecEasi::sparcc(counts)
  sparcc.out$names <- colnames(counts)
  sparcc.out
}

#' Filters the output of \code{\link{sparcc}} to a minimal treshold 
#' and transforms to matrixfor downstream clustering or heatplot visualization. 
#'
#'
#' @param ta a tidytacos object
#' @param treshold absolute value of correlations below this threshold are 
#' filtered out.
#' 
#'@export
filter_sparcc <- function(sparcc, treshold = 0.1) {
  force_optional_dependency("Matrix")
  se.sparcc.graph <- abs(sparcc$Cor) >= treshold
  Matrix::diag(se.sparcc.graph) <- 0
  sparcc.graph <- Matrix::Matrix(se.sparcc.graph, sparse = T)
  sparcc.elist <- as.data.frame(as.matrix(summary(sparcc.graph * sparcc$Cor)))
  sparcc_filtered <- as.data.frame(as.matrix(Matrix::Matrix(se.sparcc.graph) * sparcc$Cor))
  rownames(sparcc_filtered) <- sparcc$names
  colnames(sparcc_filtered) <- sparcc$names
  as.matrix(sparcc_filtered)
}

#' Performs Markov Clustering on a sparcc network matrix generated by \code{\link{filter_sparcc}}. 
#' and returns a tibble with clusters and taxon identifiers. Optionally, the network can be visualized.
#'
#' @param network sparcc network in matrix form.
#' @param min_n minimum number of taxa per cluster, smaller clusters are filtered out.
#' @param visualize wether to visualize the network clusters or not. 
#' 
#' @export
cluster_sparcc <- function(sparcc, min_n = 3, visualize = F) {
  force_optional_dependency("MCL")
  sparcc[sparcc < 0] <- 0
  res <- MCL::mcl(sparcc, addLoops = T, ESM = T)

  if (visualize) {
    force_optional_dependency("igraph")
    gd <- igraph::graph.adjacency(res$Equilibrium.state.matrix)
    plot(gd)
  }

  clusters <- tibble(taxon = colnames(sparcc), cluster = res$Cluster)
  k <- clusters %>%
    group_by(cluster) %>%
    summarize(taxa_per_clust = n()) %>%
    filter(taxa_per_clust >= min_n) %>%
    pull(cluster)

  clusters %>% filter(cluster %in% k) %>% mutate(cluster = str_c("c", cluster))
}

#' Performs SparCC network analysis on a tidytacos object 
#' and then performs Markov Clustering on the network to 
#' annotate taxa of the largest clusters in the tidytacos object.
#'
#' @param ta a tidytacos object.
#' @param rarefact Rarefaction degree: percentage of samples the taxon needs to be present in.
#' @param network_tresh absolute value of correlations below this threshold are 
#' filtered out.  
#' @param min_n_cluster minimum number of taxa per cluster, smaller clusters are filtered out. 
#' @param taxon_name unique name to use for the taxa, by default taxon_id is used. 
#' @param sample_name unique name to use for the samples, by default sample_id is used. 
#'  
#' @export
add_taxon_cluster <- function(
    ta,
    rarefact = 0.05, network_tresh = 0.1, min_n_cluster = 3,
    taxon_name = taxon, sample_name = sample) {
  sample_name <- rlang::enquo(sample_name)
  taxon_name <- rlang::enquo(taxon_name)

  clusters <- ta %>%
    sparcc(
      rarefact = rarefact,
      sample_name = !!sample_name, taxon_name = !!taxon_name
    ) %>%
    filter_sparcc(treshold = network_tresh) %>%
    cluster_sparcc(min_n = min_n_cluster)

  ta$taxa <- ta$taxa %>% left_join(clusters, by=join_by(!!taxon_name==taxon))
  ta
}


# Internal function to run pca per cluster
pca_taxa <- function(ta, cluster_name, taxon_name=taxon, sample_name=sample){

    taxon_name <- rlang::enquo(taxon_name)
    sample_name <- rlang::enquo(sample_name)

    cm <- ta %>% filter_taxa(cluster==cluster_name) %>% 
        counts_matrix(taxon_name=!!taxon_name, sample_name=!!sample_name)

    res <- cm %>% 
        stats::prcomp(scale=T)
    colname = paste0("scaled_pca_", cluster_name)
    
    res_table <- tibble(!!rlang::quo_name(sample_name):=rownames(res$x), !!colname:=res$x[,1])

    ta$samples <- ta$samples %>% left_join(
        res_table,
        by=rlang::set_names(rlang::quo_name(sample_name), rlang::quo_name(sample_name))
    )
    ta
}


#' Calculates eigentaxa values based on SparCC - MCL generated clusters per sample. 
#' It is advised to run \code{\link{add_taxon_cluster}} on the tidyamplicons object
#' before running this function to add the clusters if you want to stray from any default parameters.
#'
#' @param ta a tidytacos object.
#'  
#' @export
add_eigentaxa <- function(ta, taxon_name=taxon, sample_name=sample) {

    taxon_name <- rlang::enquo(taxon_name)
    sample_name <- rlang::enquo(sample_name)
    ta_tmp <- ta
    if (! "cluster" %in% names(ta$taxa)) {
    # keep cluster ids in tax table
    ta <- ta %>% add_taxon_cluster(taxon_name=!!taxon_name, sample_name=!!sample_name)
    ta_tmp <- ta %>% clr_transform_counts(overwrite=T)
    }

    clusters <- ta_tmp$taxa %>% drop_na() %>% pull(cluster)

    for (clust in unique(clusters)){
    tryCatch({
        ta_tmp <- pca_taxa(ta_tmp, clust, 
        taxon_name=!!taxon_name, sample_name=!!sample_name)}, 
        error=function(cond){warning(cond)}
    )
    }

    ta$samples <- ta_tmp$samples
    ta
}

