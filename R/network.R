#' Perform network inference with SparCC on a tidytacos object,
#' after dropping rare taxa. See [SpiecEasi::sparcc()].
#'
#' @param ta a tidytacos object
#' @param min_occurrence Percentage of samples the taxon
#' needs to be present in for it to be considered in the analysis.
#' @param taxon_name Column name of the taxon identifier, by default taxon.
#' @param sample_name Column name of the sample identifier, by default sample.
#' considered zero by the inner SparCC loop.
#' @param calculate_p whether to calculate p-values or not.
#' This can be time consuming due to the many iterations needed.
#' Iterations can be set with the R parameter and multiple cores through ncpus.
#' @inheritDotParams SpiecEasi::sparcc
#'@export
network <- function(ta,
  min_occurrence = 0.05, taxon_name = taxon, sample_name = sample,
  calculate_p=FALSE, ...) {
  force_optional_dependency(
    "SpiecEasi",
    "\nInstall using: install_github('zdk123/SpiecEasi')"
  )


  sample_name <- rlang::enquo(sample_name)
  taxon_name <- rlang::enquo(taxon_name)
  if (!quo_name(taxon_name) %in% names(ta$taxa)) {
    warning(paste(quo_name(taxon_name), 
    "not found in the taxa table, resorting to add_taxon_name"))
    ta <- ta %>% add_taxon_name()
    taxon_name <- sym("taxon_name")
  }

  cutoff <- nrow(ta$samples) * min_occurrence
  if (!"prevalence" %in% names(ta$taxa)) {
    ta_occ <- ta %>% add_prevalence()
  } else {
    ta_occ <- ta
  }
  ta_occ <- ta_occ %>%
    filter_taxa(prevalence >= cutoff)
  counts <- ta_occ %>%
    counts_matrix(sample_name = !!sample_name, taxon_name = !!taxon_name)
  network.out <- SpiecEasi::sparcc(counts, ...)

  if (calculate_p){
    args <- list(...)
    if (!"R" %in% names(args)) {
      network.boot <- SpiecEasi::sparccboot(counts, R=1000)
    } else {
      network.boot <- SpiecEasi::sparccboot(counts, args$R)
    }
    network.pvals <- SpiecEasi::pval.sparccboot(network.boot)

    if (any(is.na(network.pvals$pvals))) {
      warning("Some p-values are NA, consider increasing the number of bootstraps with R=...!")
      network.pvals$pvals[is.na(network.pvals$pvals)] <- 1
    }

    pvals <- network.pvals$pvals
    sparCCpval <- diag(0.5, nrow = dim(network.out$Cor)[1], ncol = dim(network.out$Cor)[1])
    sparCCpval[upper.tri(sparCCpval, diag=FALSE)] <- pvals
    sparCCpval <- sparCCpval + t(sparCCpval)
    network.out$pvals <- sparCCpval
  }

  network.out$names <- colnames(counts)
  network.out
}

#' Filters the output of [network()] to a minimal threshold
#' and transforms to matrix for downstream clustering or heatplot visualization.
#'
#'
#' @param network network object generated by [network()].
#' @param threshold absolute value of correlations below this threshold are
#' @param fdr the threshold for false discovery rate
#' (if pvalues are calculated for the network) filtered out.
#' @inheritDotParams stats::p.adjust
#' 
#'@export
filter_network <- function(network, threshold = 0.1, fdr = NULL, ...) {
  force_optional_dependency("Matrix")
  se.network.graph <- abs(network$Cor) >= threshold
  Matrix::diag(se.network.graph) <- 0

  if ("pvals" %in% names(network)) {
    # get lower triangle of pvals
    ltri <- network$pvals[lower.tri(network$pvals)]
    # calculate fdr
    ltri.adj <- ltri %>% p.adjust(...)
    # filter on fdr threshold
    if (is.null(fdr)){
      fdr <- 0.05
    }
    sparCCqval <- diag(0.5, nrow = dim(network$Cor)[1], ncol = dim(network$Cor)[1])
    sparCCqval[upper.tri(sparCCqval, diag=FALSE)] <- ltri.adj
    sparCCqval <- sparCCqval + t(sparCCqval)

    se.network.graph <- sparCCqval <= fdr
    Matrix::diag(se.network.graph) <- 0
  }

  network.graph <- Matrix::Matrix(se.network.graph, sparse = T)
  network.elist <- as.data.frame(as.matrix(summary(network.graph * network$Cor)))
  network_filtered <- as.data.frame(as.matrix(Matrix::Matrix(se.network.graph) *network$Cor))
  rownames(network_filtered) <- network$names
  colnames(network_filtered) <- network$names
  as.matrix(network_filtered)
}

#' Performs Markov Clustering on a sparcc network matrix generated by [filter_network()]. 
#' and returns a tibble with clusters and taxon identifiers. Optionally, the network can be visualized.
#'
#' @param network network network in matrix form.
#' @param min_n minimum number of taxa per cluster, smaller clusters are filtered out.
#' @param visualize whether to visualize the network clusters or not. 
#' 
#' @export
cluster_network <- function(network, min_n = 3, visualize = F) {
  force_optional_dependency("MCL")
  force_optional_dependency("Matrix")
  taxa_per_clust <- NULL

  network[network < 0] <- 0
  res <- MCL::mcl(network, ESM = T, addLoops=T)
  Matrix::diag(res$Equilibrium.state.matrix) <- 0

  if (visualize) {
    force_optional_dependency("igraph")
    gd <- igraph::graph.adjacency(res$Equilibrium.state.matrix, mode = "undirected")
    igraph::V(gd)$name <- colnames(network)
    plot(gd)
  }

  clusters <- tibble(taxon = colnames(network), cluster = res$Cluster)
  k <- clusters %>%
    group_by(cluster) %>%
    summarize(taxa_per_clust = n()) %>%
    filter(taxa_per_clust >= min_n) %>%
    pull(cluster)

  clusters %>% filter(cluster %in% k) %>% mutate(cluster = str_c("c", cluster))
}

#' Performs SparCC network analysis on a tidytacos object 
#' and then performs Markov Clustering on the network to 
#' annotate taxa of the largest clusters in the tidytacos object.
#'
#' @param ta a tidytacos object.
#' @param min_occurrence Percentage of samples the taxon needs to be present in for it to be considered in the analysis.
#' @param network_thresh absolute value of correlations below this threshold are 
#' filtered out.  
#' @param min_n_cluster minimum number of taxa per cluster, smaller clusters are filtered out. 
#' @param taxon_name unique name to use for the taxa, by default taxon_id is used. 
#' @param sample_name unique name to use for the samples, by default sample_id is used. 
#'  
#' @export
cluster_taxa <- function(
    ta,
    min_occurrence = 0.05, network_thresh = 0.1, min_n_cluster = 3,
    taxon_name = taxon, sample_name = sample) {
  sample_name <- rlang::enquo(sample_name)
  taxon_name <- rlang::enquo(taxon_name)

  clusters <- ta %>%
    network(
      min_occurrence = min_occurrence,
      sample_name = !!sample_name, taxon_name = !!taxon_name
    ) %>%
    filter_network(threshold = network_thresh) %>%
    cluster_network(min_n = min_n_cluster)

  ta$taxa <- ta$taxa %>% left_join(clusters, by=join_by(!!taxon_name==taxon))
  ta
}


# Internal function to run pca per cluster
pca_taxa <- function(ta, cluster_name, taxon_name=taxon, sample_name=sample){

    taxon_name <- rlang::enquo(taxon_name)
    sample_name <- rlang::enquo(sample_name)

    cm <- ta %>% filter_taxa(cluster==cluster_name) %>% 
        counts_matrix(taxon_name=!!taxon_name, sample_name=!!sample_name)

    res <- cm %>% 
        stats::prcomp(scale=T)
    colname = paste0("scaled_pca_", cluster_name)
    
    res_table <- tibble(!!rlang::quo_name(sample_name):=rownames(res$x), !!colname:=res$x[,1])

    ta$samples <- ta$samples %>% left_join(
        res_table,
        by=rlang::set_names(rlang::quo_name(sample_name), rlang::quo_name(sample_name))
    )
    ta
}


#' Calculates eigentaxa values based on SparCC - MCL generated clusters per sample. 
#' It is advised to run [cluster_taxa()] on the tidytacos object
#' before running this function to add the clusters if you want to stray from any default parameters.
#'
#' @param ta a tidytacos object.
#' @param taxon_name Column name of the taxon identifier, by default taxon.
#' @param sample_name Column name of the sample identifier, by default sample.
#'  
#' @export
add_eigentaxa <- function(ta, taxon_name=taxon, sample_name=sample) {

    taxon_name <- rlang::enquo(taxon_name)
    sample_name <- rlang::enquo(sample_name)
    ta_tmp <- ta
    if (! "cluster" %in% names(ta$taxa)) {
    # keep cluster ids in tax table
    ta <- ta %>% cluster_taxa(taxon_name=!!taxon_name, sample_name=!!sample_name)
    ta_tmp <- ta %>% add_clr_abundance(overwrite=T)
    }

    clusters <- ta_tmp$taxa %>% drop_na() %>% pull(cluster)

    for (clust in unique(clusters)){
    tryCatch({
        ta_tmp <- pca_taxa(ta_tmp, clust, 
        taxon_name=!!taxon_name, sample_name=!!sample_name)}, 
        error=function(cond){warning(cond)}
    )
    }

    ta$samples <- ta_tmp$samples
    ta
}

