#' Perform network inference with SparCC on a tidytacos object, 
#' after rarefaction of the taxa. See \link[SpiecEasi]{sparcc}.
#'
#' @param ta a tidytacos object
#' @param rarefact Rarefaction degree: percentage of samples the taxon needs to be present in.
#' @param iter Number of iterations in the outer loop
#' @param inner_iter Number of iterations in the inner loop
#' @param th absolute value of correlations below this threshold are 
#' considered zero by the inner SparCC loop.
#' 
#'@export
network <- function(ta, rarefact = 0.05, taxon_name = taxon, sample_name = sample, ...) {
  force_optional_dependency(
    "SpiecEasi",
    "\nInstall using: install_github('zdk123/SpiecEasi')"
  )


  sample_name <- rlang::enquo(sample_name)
  taxon_name <- rlang::enquo(taxon_name)
  if (!quo_name(taxon_name) %in% names(ta$taxa)) {
    warning(paste(quo_name(taxon_name), "not found in the taxa table, resorting to add_taxon_name"))
    ta <- ta %>% add_taxon_name()
    taxon_name <- sym("taxon_name")
  }

  cutoff <- nrow(ta$samples) * rarefact
  if (!"prevalence" %in% names(ta$taxa)) {
    ta_occ <- ta %>% add_prevalence()
  } else {
    ta_occ <- ta
  }
  ta_occ <- ta_occ %>%
    filter_taxa(prevalence >= cutoff)
  counts <- ta_occ %>%
    counts_matrix(sample_name = !!sample_name, taxon_name = !!taxon_name)
  network.out <- SpiecEasi::sparcc(counts, ...)
  network.out$names <- colnames(counts)
  network.out
}

#' Filters the output of \code{\link{network}} to a minimal threshold 
#' and transforms to matrix for downstream clustering or heatplot visualization. 
#'
#'
#' @param ta a tidytacos object
#' @param threshold absolute value of correlations below this threshold are 
#' filtered out.
#' 
#'@export
filter_network <- function(network, threshold = 0.1) {
  force_optional_dependency("Matrix")
  se.network.graph <- abs(network$Cor) >= threshold
  Matrix::diag(se.network.graph) <- 0
  network.graph <- Matrix::Matrix(se.network.graph, sparse = T)
  network.elist <- as.data.frame(as.matrix(summary(network.graph * network$Cor)))
  network_filtered <- as.data.frame(as.matrix(Matrix::Matrix(se.network.graph) *network$Cor))
  rownames(network_filtered) <- network$names
  colnames(network_filtered) <-network$names
  as.matrix(network_filtered)
}

#' Performs Markov Clustering on a sparcc network matrix generated by \code{\link{filter_network}}. 
#' and returns a tibble with clusters and taxon identifiers. Optionally, the network can be visualized.
#'
#' @param network network network in matrix form.
#' @param min_n minimum number of taxa per cluster, smaller clusters are filtered out.
#' @param visualize whether to visualize the network clusters or not. 
#' 
#' @export
cluster_network <- function(network, min_n = 3, visualize = F) {
  force_optional_dependency("MCL")
  network[network < 0] <- 0
  res <- MCL::mcl(network, ESM = T)

  if (visualize) {
    force_optional_dependency("igraph")
    gd <- igraph::graph.adjacency(res$Equilibrium.state.matrix, mode = "undirected")
    igraph::V(gd)$name <- colnames(network)
    plot(gd)
  }

  clusters <- tibble(taxon = colnames(network), cluster = res$Cluster)
  k <- clusters %>%
    group_by(cluster) %>%
    summarize(taxa_per_clust = n()) %>%
    filter(taxa_per_clust >= min_n) %>%
    pull(cluster)

  clusters %>% filter(cluster %in% k) %>% mutate(cluster = str_c("c", cluster))
}

#' Performs SparCC network analysis on a tidytacos object 
#' and then performs Markov Clustering on the network to 
#' annotate taxa of the largest clusters in the tidytacos object.
#'
#' @param ta a tidytacos object.
#' @param rarefact Rarefaction degree: percentage of samples the taxon needs to be present in.
#' @param network_thresh absolute value of correlations below this threshold are 
#' filtered out.  
#' @param min_n_cluster minimum number of taxa per cluster, smaller clusters are filtered out. 
#' @param taxon_name unique name to use for the taxa, by default taxon_id is used. 
#' @param sample_name unique name to use for the samples, by default sample_id is used. 
#'  
#' @export
cluster_taxa <- function(
    ta,
    rarefact = 0.05, network_thresh = 0.1, min_n_cluster = 3,
    taxon_name = taxon, sample_name = sample) {
  sample_name <- rlang::enquo(sample_name)
  taxon_name <- rlang::enquo(taxon_name)

  clusters <- ta %>%
    network(
      rarefact = rarefact,
      sample_name = !!sample_name, taxon_name = !!taxon_name
    ) %>%
    filter_network(threshold = network_thresh) %>%
    cluster_network(min_n = min_n_cluster)

  ta$taxa <- ta$taxa %>% left_join(clusters, by=join_by(!!taxon_name==taxon))
  ta
}


# Internal function to run pca per cluster
pca_taxa <- function(ta, cluster_name, taxon_name=taxon, sample_name=sample){

    taxon_name <- rlang::enquo(taxon_name)
    sample_name <- rlang::enquo(sample_name)

    cm <- ta %>% filter_taxa(cluster==cluster_name) %>% 
        counts_matrix(taxon_name=!!taxon_name, sample_name=!!sample_name)

    res <- cm %>% 
        stats::prcomp(scale=T)
    colname = paste0("scaled_pca_", cluster_name)
    
    res_table <- tibble(!!rlang::quo_name(sample_name):=rownames(res$x), !!colname:=res$x[,1])

    ta$samples <- ta$samples %>% left_join(
        res_table,
        by=rlang::set_names(rlang::quo_name(sample_name), rlang::quo_name(sample_name))
    )
    ta
}


#' Calculates eigentaxa values based on SparCC - MCL generated clusters per sample. 
#' It is advised to run \code{\link{cluster_taxa}} on the tidyamplicons object
#' before running this function to add the clusters if you want to stray from any default parameters.
#'
#' @param ta a tidytacos object.
#'  
#' @export
add_eigentaxa <- function(ta, taxon_name=taxon, sample_name=sample) {

    taxon_name <- rlang::enquo(taxon_name)
    sample_name <- rlang::enquo(sample_name)
    ta_tmp <- ta
    if (! "cluster" %in% names(ta$taxa)) {
    # keep cluster ids in tax table
    ta <- ta %>% cluster_taxa(taxon_name=!!taxon_name, sample_name=!!sample_name)
    ta_tmp <- ta %>% add_clr_abundance(overwrite=T)
    }

    clusters <- ta_tmp$taxa %>% drop_na() %>% pull(cluster)

    for (clust in unique(clusters)){
    tryCatch({
        ta_tmp <- pca_taxa(ta_tmp, clust, 
        taxon_name=!!taxon_name, sample_name=!!sample_name)}, 
        error=function(cond){warning(cond)}
    )
    }

    ta$samples <- ta_tmp$samples
    ta
}

